use std::sync::{Arc, Mutex};
use std::time::{SystemTime, UNIX_EPOCH};
use tokio::net::{UnixListener, UnixStream};
use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};

use crate::ipc::{BackendMessage, FrontendMessage, ClipboardItem, ClipboardContentType};

pub struct ClipboardBackend {
    history: Arc<Mutex<Vec<ClipboardItem>>>,
    next_id: Arc<Mutex<u64>>,
}

pub struct BackendState {
    backend: Arc<Mutex<ClipboardBackend>>,
}

impl BackendState {
    pub fn new() -> Self {
        Self {
            backend: Arc::new(Mutex::new(ClipboardBackend {
                history: Arc::new(Mutex::new(Vec::new())),
                next_id: Arc::new(Mutex::new(1)),
            })),
        }
    }

    pub fn add_clipboard_item(&mut self, content: String) {
        let backend = self.backend.lock().unwrap();
        let mut history = backend.history.lock().unwrap();
        let mut next_id = backend.next_id.lock().unwrap();

        let item = ClipboardItem {
            id: *next_id,
            content_type: ClipboardContentType::from_content(&content),
            content,
            timestamp: SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs(),
        };

        // Remove duplicate if it exists
        history.retain(|existing| existing.content != item.content);
        
        // Add to front
        history.insert(0, item);
        
        // Keep only last 100 items
        if history.len() > 100 {
            history.truncate(100);
        }

        *next_id += 1;
    }

    pub fn get_history(&self) -> Vec<ClipboardItem> {
        let backend = self.backend.lock().unwrap();
        let history = backend.history.lock().unwrap();
        history.clone()
    }

    pub fn clear_history(&mut self) {
        let backend = self.backend.lock().unwrap();
        let mut history = backend.history.lock().unwrap();
        history.clear();
    }

    pub fn set_clipboard(&self, content: String) -> Result<(), String> {
        // For now, just add it to history as a placeholder
        // In a real implementation, this would set the system clipboard
        println!("Setting clipboard content: {}", content);
        Ok(())
    }
}

pub async fn run_backend() -> Result<(), Box<dyn std::error::Error>> {
    // Remove existing socket if it exists
    let socket_path = "/tmp/cursor-clip.sock";
    let _ = std::fs::remove_file(socket_path);

    // Create Unix socket for IPC
    let listener = UnixListener::bind(socket_path)?;
    println!("Clipboard backend listening on {}", socket_path);

    // Simple state for testing
    let state = Arc::new(Mutex::new(BackendState::new()));

    // Add some sample data
    {
        let mut state_lock = state.lock().unwrap();
        state_lock.add_clipboard_item("Hello, world!".to_string());
        state_lock.add_clipboard_item("https://github.com/rust-lang/rust".to_string());
        state_lock.add_clipboard_item("Sample clipboard content for testing the clipboard manager".to_string());
        state_lock.add_clipboard_item("impl Display for MyStruct {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"MyStruct\")\n    }\n}".to_string());
        state_lock.add_clipboard_item("Password123!Jannik2".to_string());
    }

    // Handle IPC connections
    loop {
        let (stream, _addr) = listener.accept().await?;
        let state_clone = state.clone();
        
        tokio::spawn(async move {
            if let Err(e) = handle_client(stream, state_clone).await {
                eprintln!("Client error: {}", e);
            }
        });
    }
}

async fn handle_client(
    stream: UnixStream,
    state: Arc<Mutex<BackendState>>,
) -> Result<(), Box<dyn std::error::Error>> {
    let (reader, mut writer) = stream.into_split();
    let mut lines = BufReader::new(reader).lines();

    while let Some(line) = lines.next_line().await? {
        let message: FrontendMessage = serde_json::from_str(&line)?;
        
        let response = match message {
            FrontendMessage::GetHistory => {
                let state = state.lock().unwrap();
                let items = state.get_history();
                BackendMessage::History { items }
            }
            FrontendMessage::SetClipboard { content } => {
                let state = state.lock().unwrap();
                match state.set_clipboard(content) {
                    Ok(_) => BackendMessage::ClipboardSet,
                    Err(e) => BackendMessage::Error { message: e },
                }
            }
            FrontendMessage::ClearHistory => {
                let mut state = state.lock().unwrap();
                state.clear_history();
                BackendMessage::HistoryCleared
            }
            FrontendMessage::ShowAt { .. } | FrontendMessage::Close => {
                // These are handled by the frontend, not the backend
                continue;
            }
        };

        let response_json = serde_json::to_string(&response)?;
        writer.write_all(response_json.as_bytes()).await?;
        writer.write_all(b"\n").await?;
    }

    Ok(())
}
