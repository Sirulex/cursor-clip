use std::sync::{Arc, Mutex};
use std::time::{SystemTime, UNIX_EPOCH};
use tokio::net::{UnixListener, UnixStream};
use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};

use crate::ipc::{BackendMessage, FrontendMessage, ClipboardItem, ClipboardContentType};

pub struct ClipboardBackend {
    history: Arc<Mutex<Vec<ClipboardItem>>>,
    next_id: Arc<Mutex<u64>>,
    data_control_manager: Option<zwlr_data_control_manager_v1::ZwlrDataControlManagerV1>,
    data_control_device: Option<zwlr_data_control_device_v1::ZwlrDataControlDeviceV1>,
    seat: Option<wl_seat::WlSeat>,
}

pub struct BackendState {
    backend: Arc<Mutex<ClipboardBackend>>,
}

impl BackendState {
    pub fn new() -> Self {
        Self {
            backend: Arc::new(Mutex::new(ClipboardBackend {
                history: Arc::new(Mutex::new(Vec::new())),
                next_id: Arc::new(Mutex::new(1)),
                data_control_manager: None,
                data_control_device: None,
                seat: None,
            })),
        }
    }

    pub fn add_clipboard_item(&mut self, content: String) {
        let backend = self.backend.lock().unwrap();
        let mut history = backend.history.lock().unwrap();
        let mut next_id = backend.next_id.lock().unwrap();

        let item = ClipboardItem {
            id: *next_id,
            content_type: ClipboardContentType::from_content(&content),
            content,
            timestamp: SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs(),
        };

        // Remove duplicate if it exists
        history.retain(|existing| existing.content != item.content);
        
        // Add to front
        history.insert(0, item);
        
        // Keep only last 100 items
        if history.len() > 100 {
            history.truncate(100);
        }

        *next_id += 1;
    }

    pub fn get_history(&self) -> Vec<ClipboardItem> {
        let backend = self.backend.lock().unwrap();
        let history = backend.history.lock().unwrap();
        history.clone()
    }

    pub fn clear_history(&mut self) {
        let backend = self.backend.lock().unwrap();
        let mut history = backend.history.lock().unwrap();
        history.clear();
    }

    pub fn set_clipboard(&self, content: String) -> Result<(), String> {
        let backend = self.backend.lock().unwrap();
        
        if let (Some(_manager), Some(_seat)) = (&backend.data_control_manager, &backend.seat) {
            // Create a data source for setting clipboard content
            // This would typically involve creating a zwlr_data_control_source_v1
            // and setting the clipboard content through the Wayland protocol
            
            // For now, we'll just add it to history as a placeholder
            drop(backend);
            // This is a bit of a hack since we need mutable access
            // In a real implementation, you'd handle this more elegantly
            println!("Setting clipboard content: {}", content);
            Ok(())
        } else {
            Err("Data control manager not available".to_string())
        }
    }
}

pub async fn run_backend() -> Result<(), Box<dyn std::error::Error>> {
    // Remove existing socket if it exists
    let socket_path = "/tmp/cursor-clip.sock";
    let _ = std::fs::remove_file(socket_path);

    // For now, let's skip the complex Wayland clipboard integration and just focus on IPC
    // This will be a placeholder backend that manages clipboard history in memory
    
    // Create Unix socket for IPC
    let listener = UnixListener::bind(socket_path)?;
    println!("Clipboard backend listening on {}", socket_path);

    // Simple state for testing
    let state = Arc::new(Mutex::new(BackendState::new()));

    // Add some sample data
    {
        let mut state_lock = state.lock().unwrap();
        state_lock.add_clipboard_item("Hello, world!".to_string());
        state_lock.add_clipboard_item("https://github.com/rust-lang/rust".to_string());
        state_lock.add_clipboard_item("Sample clipboard content".to_string());
    }

    // Handle IPC connections
    loop {
        let (stream, _addr) = listener.accept().await?;
        let state_clone = state.clone();
        
        tokio::spawn(async move {
            if let Err(e) = handle_client(stream, state_clone).await {
                eprintln!("Client error: {}", e);
            }
        });
    }
}

async fn handle_client(
    stream: UnixStream,
    state: Arc<Mutex<BackendState>>,
) -> Result<(), Box<dyn std::error::Error>> {
    let (reader, mut writer) = stream.into_split();
    let mut lines = BufReader::new(reader).lines();

    while let Some(line) = lines.next_line().await? {
        let message: FrontendMessage = serde_json::from_str(&line)?;
        
        let response = match message {
            FrontendMessage::GetHistory => {
                let state = state.lock().unwrap();
                let items = state.get_history();
                BackendMessage::History { items }
            }
            FrontendMessage::SetClipboard { content } => {
                let state = state.lock().unwrap();
                match state.set_clipboard(content) {
                    Ok(_) => BackendMessage::ClipboardSet,
                    Err(e) => BackendMessage::Error { message: e },
                }
            }
            FrontendMessage::ClearHistory => {
                let mut state = state.lock().unwrap();
                state.clear_history();
                BackendMessage::HistoryCleared
            }
            FrontendMessage::ShowAt { .. } | FrontendMessage::Close => {
                // These are handled by the frontend, not the backend
                continue;
            }
        };

        let response_json = serde_json::to_string(&response)?;
        writer.write_all(response_json.as_bytes()).await?;
        writer.write_all(b"\n").await?;
    }

    Ok(())
}

// Wayland event handlers would go here
// This is a simplified version - you'd need to implement proper event handling
// for zwlr_data_control_device_v1 events to detect clipboard changes

impl wayland_client::Dispatch<zwlr_data_control_manager_v1::ZwlrDataControlManagerV1, ()> for BackendState {
    fn event(
        _state: &mut Self,
        _proxy: &zwlr_data_control_manager_v1::ZwlrDataControlManagerV1,
        _event: <zwlr_data_control_manager_v1::ZwlrDataControlManagerV1 as wayland_client::Proxy>::Event,
        _data: &(),
        _conn: &Connection,
        _qhandle: &wayland_client::QueueHandle<Self>,
    ) {
        // Handle data control manager events
    }
}

impl wayland_client::Dispatch<zwlr_data_control_device_v1::ZwlrDataControlDeviceV1, ()> for BackendState {
    fn event(
        _state: &mut Self,
        _proxy: &zwlr_data_control_device_v1::ZwlrDataControlDeviceV1,
        event: <zwlr_data_control_device_v1::ZwlrDataControlDeviceV1 as wayland_client::Proxy>::Event,
        _data: &(),
        _conn: &Connection,
        _qhandle: &wayland_client::QueueHandle<Self>,
    ) {
        use zwlr_data_control_device_v1::Event;
        
        match event {
            Event::DataOffer { id } => {
                println!("New data offer received: {:?}", id);
                // Handle new clipboard content
            }
            Event::Selection { id } => {
                println!("Clipboard selection changed: {:?}", id);
                // This is where we'd read the new clipboard content
                // and add it to our history
            }
            Event::PrimarySelection { id } => {
                println!("Primary selection changed: {:?}", id);
            }
            _ => {}
        }
    }
}

impl wayland_client::Dispatch<zwlr_data_control_offer_v1::ZwlrDataControlOfferV1, ()> for BackendState {
    fn event(
        _state: &mut Self,
        _proxy: &zwlr_data_control_offer_v1::ZwlrDataControlOfferV1,
        _event: <zwlr_data_control_offer_v1::ZwlrDataControlOfferV1 as wayland_client::Proxy>::Event,
        _data: &(),
        _conn: &Connection,
        _qhandle: &wayland_client::QueueHandle<Self>,
    ) {
        // Handle data offer events
    }
}

impl wayland_client::Dispatch<wl_seat::WlSeat, ()> for BackendState {
    fn event(
        _state: &mut Self,
        _proxy: &wl_seat::WlSeat,
        _event: <wl_seat::WlSeat as wayland_client::Proxy>::Event,
        _data: &(),
        _conn: &Connection,
        _qhandle: &wayland_client::QueueHandle<Self>,
    ) {
        // Handle seat events
    }
}

// Registry dispatch for the backend
impl wayland_client::Dispatch<wl_registry::WlRegistry, wayland_client::globals::GlobalListContents> for BackendState {
    fn event(
        _state: &mut Self,
        _proxy: &wl_registry::WlRegistry,
        _event: <wl_registry::WlRegistry as wayland_client::Proxy>::Event,
        _data: &wayland_client::globals::GlobalListContents,
        _conn: &Connection,
        _qhandle: &wayland_client::QueueHandle<Self>,
    ) {
        // Handle registry events for global discovery
    }
}
